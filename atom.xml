<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mikado&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mikado.drrr.app/"/>
  <updated>2020-04-13T07:03:56.329Z</updated>
  <id>https://mikado.drrr.app/</id>
  
  <author>
    <name>Mikado</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>译：InnoDB索引</title>
    <link href="https://mikado.drrr.app/InnoDB-Indexes-Translation/"/>
    <id>https://mikado.drrr.app/InnoDB-Indexes-Translation/</id>
    <published>2020-04-13T06:30:50.000Z</published>
    <updated>2020-04-13T07:03:56.329Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/InnoDB-Indexes-Translation/87c01ec7gy1frkhzeordxj21kw0zke81.jpg" alt=""></p><blockquote><p>翻译原文档地址：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html</a></p></blockquote><h2 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h2><p>每个<code>InnoDB</code>表都有一个特殊的索引，称为<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a>，用于存储行数据。通常，聚簇索引与<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>同义。为了从查询，插入，和其他数据操作上获得最佳性能，你必须了解<code>InnoDB</code>如果使用聚簇索引为每个表优化最常见的查找和DML操作。</p><a id="more"></a><ul><li>当你在表上定义了一个<code>PRIMARY KEY</code>，<code>InnoDB</code>将使用它作为聚簇索引。为你创建的每一个表定义一个主键。如果没有逻辑唯一且非空的列或者列集，请添加一个新的自增列，其值将自动填充。</li><li>如果你没有为你的表定义一个<code>PRIMARY KEY</code>，MySQL会在所有键列都<code>NOT NULL</code>的情况下找到第一个<code>UNIQUE</code>索引，<code>InnoDB</code>会使用它作为聚簇索引。</li><li>如果表没有<code>PRIMARY KEY</code>或合适的<code>UNIQUE</code>索引，<code>InnoDB</code>在包含行ID值的综合列上内部生成一个名为<code>GEN_CLUST_INDEX</code>的隐藏的聚簇索引。这些行由<code>InnoDB</code>分配给此类表中的行ID排序。这些行ID是一个6字节的字段，随着插入新行而单调增加。因此，按行ID排序的行是物理上按插入顺序排列。</li></ul><h3 id="聚簇索引如何加快查询速度"><a href="#聚簇索引如何加快查询速度" class="headerlink" title="聚簇索引如何加快查询速度"></a>聚簇索引如何加快查询速度</h3><p>通过聚簇索引访问行是快速的，因为索引搜索直接指向含所有行数据的页面。假如一个表很大，与使用不同于与索引记录的页面存储行数据的存储方式相比，聚簇索引结构通常可以节省磁盘I/O操作。</p><h3 id="二级索引如果与聚簇索引关联"><a href="#二级索引如果与聚簇索引关联" class="headerlink" title="二级索引如果与聚簇索引关联"></a>二级索引如果与聚簇索引关联</h3><p>除聚簇索引外的所有索引都称为<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">二级索引</a>。在<code>InnoDB</code>里，在二级索引的每个记录都包含该行的主键列，以及为二级索引知道的列。<code>InnoDB</code>使用此主键值在聚簇索引中搜索行。</p><p>假如主键较长，则二级索引会使用更多空间，因此具有短主键是有利的。</p><p>有关利用<code>InnoDB</code>聚簇索引和二级索引的指南，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html" target="_blank" rel="noopener">Section 8.3 “优化和索引”</a>。</p><h2 id="InnoDB索引的物理结构"><a href="#InnoDB索引的物理结构" class="headerlink" title="InnoDB索引的物理结构"></a>InnoDB索引的物理结构</h2><p>除了空间索引，<code>InnoDB</code>索引都是<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B-Tree</a>数据结构。空间索引使用<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_r_tree" target="_blank" rel="noopener">R-trees</a>，R-trees是用于索引多维数据的专用数据结构。索引记录存储在B-tree或R-tree数据结构的叶子页上。默认索引页的大小是16KB。</p><p>当一个新记录插入到<code>InnoDB</code>的聚簇索引时，<code>InnoDB</code>尝试让页的$1/16$空闲，以供将来插入和更新索引记录。假如索引记录顺序（升序或降序）插入，产生的索引页大约占满$15/16$。如果以随机顺序插入记录，则页面的容量为$1/2$到$15/16$。</p><p><code>InnoDB</code>在创建或重建B-tree索引时执行批量加载。这种索引创建方法称为排序索引构建。<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a>配置选项定义了在排序索引构建期间填充的每个B-tree页上的空间百分比，剩余的空间供将来索引增长使用。排序索引构建不支持空间索引。更多信息查看<a href="https://dev.mysql.com/doc/refman/8.0/en/sorted-index-builds.html" target="_blank" rel="noopener">Section 15.6.2.3，“排序索引构建”</a>。设置为100的<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a>会使聚簇索引页中的空间的$1/16$空闲，以供将来索引增长。</p><p>如果<code>InnoDB</code>索引页的填充因子低于<code>MERGE_THRESHOLD</code>（如果未指定，默认值为50%），则<code>InnoDB</code>尝试收缩索引树以释放页。<code>MERGE_THRESHOLD</code>设置适用于B-tree和R-tree索引。更多信息，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/index-page-merge-threshold.html" target="_blank" rel="noopener">Section 15.8.11，“配置索引页的合并阈值”</a>。</p><p>你可以在初始化MySQL实例之前，通过设置<a href=""><code>innodb_page_size</code></a>配置选项来定义MySQL实例中所有<code>InnoDB</code>表空间的<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_size" target="_blank" rel="noopener">页大小</a>。一旦一个实例的页大小被定义，你不能修改它，除了重新初始化实例。支持的大小有：64KB，32KB，16KB（默认），8KB和4KB。</p><p>使用特定<code>InnoDB</code>页大小的MySQL实例不能使用来自不同页面大小的实例中的数据文件或日志文件。</p><h2 id="排序索引构建"><a href="#排序索引构建" class="headerlink" title="排序索引构建"></a>排序索引构建</h2><p><code>InnoDB</code>在创建或重建B-tree索引时执行批量加载。这种索引创建方法称为排序索引构建。<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a>配置选项定义了在排序索引构建期间填充的每个B-tree页上的空间百分比，剩余的空间供将来索引增长使用。排序索引构建不支持空间索引。</p><p>一个索引构建有三个阶段。在第一阶段，扫描<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚簇索引</a>，生成索引项并添加到排序缓冲区。当<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_sort_buffer" target="_blank" rel="noopener">排序缓冲区</a>满了，索引项在排序后，写入到临时中间文件。此过程也称为“<code>运行（run）</code>”。在第二阶段，在一个或多个<code>runs</code>写入到临时中间文件中，对文件的条目执行合并排序。在第三阶段也是最后节点，排序后的条目插入到<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B-tree</a>中。</p><p>在介绍排序索引构建前，通过插入API将索引项一次插入到B-tree的一条记录中。这个方法涉及打开B-tree<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_cursor" target="_blank" rel="noopener">游标（cursor）</a>以找到插入位置，然后使用<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimistic" target="_blank" rel="noopener">乐观（optimistic）</a>插入将条目插入B-tree页中。如果由于页满了导致插入失败的，将使用<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_pessimistic" target="_blank" rel="noopener">悲观（pessimistic）</a>插入，它涉及到打开一个B-tree游标并根据需要拆分和合并B-tree节点以找到索引项空间。这种“自上而下”的构建索引方法的缺点是搜索插入位置的成本和B-tree节点的不断拆分和合并的成本。</p><p>排序索引构建是使用“自下而上”方法构建索引。使用这种方法，B-tree的所有级别都包含了对最右叶子页的引用。在必要的B-tree深度处分配最右叶子页，并根据其排序顺序插入条目。一旦叶子页满了，节点指针将附加到父页，并且为下一个插入分配同级叶子页。这个过程将一直持续到插入所有索引项为止，这可能会导致插入到根级别。分配同级页后，将释放对先前固定的叶子页的引用，最新分配的叶子页将成为为最右叶子页和新默认插入位置。</p><h3 id="保留B-tree页空间以供为了索引增长"><a href="#保留B-tree页空间以供为了索引增长" class="headerlink" title="保留B-tree页空间以供为了索引增长"></a>保留B-tree页空间以供为了索引增长</h3><p>要为将来的索引增长留出空间，可以使用<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a>配置选项设置保留B-tree空间的百分比。例如，将<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a>设置为80可以在排序索引构建期间为B-tree空间保留20%的空间。此设置适用于B-tree叶子页和非叶子页。不适用于用于<code>TEXT</code>或<code>BLOB</code>索引项的外部页。保留的空间量不一定和配置完全相同，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a>值解释为提示而不是强制约束。</p><h3 id="排序索引构建和全文索引支持"><a href="#排序索引构建和全文索引支持" class="headerlink" title="排序索引构建和全文索引支持"></a>排序索引构建和全文索引支持</h3><p>全文索引支持排序索引构建。以前，SQL是用于将索引项插入到全文索引的。</p><h3 id="排序索引构建和压缩表"><a href="#排序索引构建和压缩表" class="headerlink" title="排序索引构建和压缩表"></a>排序索引构建和压缩表</h3><p>对于<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_compression" target="_blank" rel="noopener">压缩表</a>，以前的索引创建方法是将索引项附加到压缩和未压缩页面上的。修改日志（表示压缩页面上的可用空间）已满是，压缩页将重新压缩。假如由于缺乏空间导致压缩失败，页将被拆分。使用排序索引构建，索引项只附加到未压缩页上。当未压缩页满了时，未压缩页会被压缩。自适应填充用于确保大多数情况下压缩成功，但是假如压缩失败，页会被拆分并再次尝试重新压缩。此过程一直持续到压缩成功。关于B-Tree页压缩的更多信息，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-compression-internals.html" target="_blank" rel="noopener">Section 15.9.1.5，“压缩如何为InnoDB表工作”</a>。</p><h3 id="排序索引构建和重做日志记录"><a href="#排序索引构建和重做日志记录" class="headerlink" title="排序索引构建和重做日志记录"></a>排序索引构建和重做日志记录</h3><p>在排序索引构建期间，重做日志记录是被禁用的。反而，有一个<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_checkpoint" target="_blank" rel="noopener">检查点（checkpoint）</a>来确保索引构建能够经受崩溃或失败。检查点强制将所有脏页写入磁盘。在排序索引构建期间，<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_cleaner" target="_blank" rel="noopener">页面清洁器</a>线程定期发出清理脏页的信号，以确保检查点操作能够被快速处理。通常，当清洁页面数低于设置的阈值时，页面清洁器线程将刷新脏页。对排序索引构建来说，及时清除脏页，以减少检查点开销（overhead），并行I/O和CPU活动。</p><h3 id="排序索引构建和优化器统计"><a href="#排序索引构建和优化器统计" class="headerlink" title="排序索引构建和优化器统计"></a>排序索引构建和优化器统计</h3><p>排序索引构建在优化器统计的结果与由以前索引创建方法生成的那些是不同的。由于用于填充索引的算法不同，统计信息是有差异存在（预计不会影响工作负载性能）。</p><h2 id="InnoDB全文索引"><a href="#InnoDB全文索引" class="headerlink" title="InnoDB全文索引"></a>InnoDB全文索引</h2><p>创建在基于文本的列（<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>，<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>或<a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列）上的<code>全文（FULLTEXT）</code>索引，以帮助加快对那些列中包含的数据查询和DML操作，忽略定义为停用词的任何单词。</p><p><code>全文（FULLTEXT）</code>索引定义为<a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句或使用<a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>或<a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html" target="_blank" rel="noopener"><code>CREATE INDEX</code></a>添加到现有表中。</p><p>使用<a href="https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html#function_match" target="_blank" rel="noopener"><code>MATCH() ... AGAINST</code></a>语法执行全文搜索。有关使用信息，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html" target="_blank" rel="noopener">Section 12.9，“全文搜索功能”</a></p><p>本节以下主题介绍了<code>InnoDB</code>的<code>全文（FULLTEXT）</code>索引：</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-design" target="_blank" rel="noopener">InnoDB Full-Text Index Design</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-tables" target="_blank" rel="noopener">InnoDB Full-Text Index Tables</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-cache" target="_blank" rel="noopener">InnoDB Full-Text Index Cache</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-docid" target="_blank" rel="noopener">InnoDB Full-Text Index Document ID and FTS_DOC_ID Column</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-deletion" target="_blank" rel="noopener">InnoDB Full-Text Index Deletion Handling</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-transaction" target="_blank" rel="noopener">InnoDB Full-Text Index Transaction Handling</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-monitoring" target="_blank" rel="noopener">Monitoring InnoDB Full-Text Indexes</a></li></ul><p>…TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/InnoDB-Indexes-Translation/87c01ec7gy1frkhzeordxj21kw0zke81.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻译原文档地址：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;聚簇索引和二级索引&quot;&gt;&lt;a href=&quot;#聚簇索引和二级索引&quot; class=&quot;headerlink&quot; title=&quot;聚簇索引和二级索引&quot;&gt;&lt;/a&gt;聚簇索引和二级索引&lt;/h2&gt;&lt;p&gt;每个&lt;code&gt;InnoDB&lt;/code&gt;表都有一个特殊的索引，称为&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;聚簇索引&lt;/a&gt;，用于存储行数据。通常，聚簇索引与&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;主键&lt;/a&gt;同义。为了从查询，插入，和其他数据操作上获得最佳性能，你必须了解&lt;code&gt;InnoDB&lt;/code&gt;如果使用聚簇索引为每个表优化最常见的查找和DML操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="InnoDB" scheme="https://mikado.drrr.app/tags/InnoDB/"/>
    
      <category term="MySQL" scheme="https://mikado.drrr.app/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>译：InnoDB锁定</title>
    <link href="https://mikado.drrr.app/InnoDB-Locking-Translation/"/>
    <id>https://mikado.drrr.app/InnoDB-Locking-Translation/</id>
    <published>2020-04-06T05:24:52.000Z</published>
    <updated>2020-04-06T06:27:30.139Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/InnoDB-Locking-Translation/69174779_p0.jpg" alt=""></p><blockquote><p>翻译文档地址：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</a></p></blockquote><h2 id="共享锁与排他锁（Shared-and-Exclusive-Locks）"><a href="#共享锁与排他锁（Shared-and-Exclusive-Locks）" class="headerlink" title="共享锁与排他锁（Shared and Exclusive Locks）"></a>共享锁与排他锁（Shared and Exclusive Locks）</h2><p><code>InnoDB</code>实现了标准行锁定，其中有两种类型锁：<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock" target="_blank" rel="noopener">共享（<code>S</code>）锁</a> 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock" target="_blank" rel="noopener">排他（<code>X</code>）锁</a></p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock" target="_blank" rel="noopener">共享锁</a>允许持有该锁的事务读取一行。</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock" target="_blank" rel="noopener">排他锁</a>允许持有该所的事务更新或删除一行。</li></ul><p>假如事务<code>T1</code>在行<code>r</code>上持有共享（<code>S</code>）锁，然后，不同的事务<code>T2</code>请求行<code>r</code>上的锁时，处理方法如下：</p><ul><li><code>T2</code>对<code>S</code>锁的请求会被立即同意（granted immediately）。结果是，<code>T1</code>和<code>T2</code>在<code>r</code>上都将持有<code>S</code>锁。</li><li><code>T2</code>对<code>X</code>锁的请求不会被立即同意。</li></ul><p>如果事务<code>T1</code>持有对行<code>r</code>的排他（<code>X</code>）锁，来自不同事务<code>T2</code>的请求<code>r</code>上的两种类型的锁都不会被立即同意。反而，事务<code>T2</code>必须等待事务<code>T1</code>释放对行<code>r</code>的锁。</p><a id="more"></a><h2 id="意向锁（Intention-Locks）"><a href="#意向锁（Intention-Locks）" class="headerlink" title="意向锁（Intention Locks）"></a>意向锁（Intention Locks）</h2><p><code>InnoDB</code>支持<em>多粒度锁（multiple granularity locking）</em>来允许行锁和表锁共存。举个例子，像<a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES ... WRITE</code></a>在特殊表中会持有排他锁（一个<code>X</code>锁）。为了锁在多粒度级别下可行，<code>InnoDB</code>使用了<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_lock" target="_blank" rel="noopener">意向锁</a>。意向锁是表级锁，表明一个事务稍后对表中的行需要哪种类型的锁（共享或排他）。有两种类型的意向锁：</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_shared_lock" target="_blank" rel="noopener">意向共享锁</a>（<code>IS</code>）表明事务打算在表中的各个行上设置<em>共享</em>锁。</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_exclusive_lock" target="_blank" rel="noopener">意向排他锁</a>（<code>IX</code>）表明事务打算在表中的各个行上设置排他锁。</li></ul><p>例如，<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR SHARE</code></a>设置一个<code>IS</code>锁，而<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR UPDATE</code></a>设置一个<code>IX</code>锁。</p><p>意向锁协议如下：</p><ul><li>在一个事务获取表中某行的共享锁之前，它必须首先获得该表中的<code>IS</code>锁或更强的锁。</li><li>在一个事务获取表中某行的排他锁之前，它必须首先获得该表中的<code>IX</code>锁。</li></ul><p>表级锁类型的兼容性整理在以下表中。</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>如果事务的一个锁请求与现有锁是兼容的，则锁请求会被同意（granted），但是如果与现有锁冲突的，则锁请求不会被同意。事务会等待直到冲突的现有锁被释放。如果一个锁请求与现有锁冲突并且由于可能导致死锁而无法同意，则会发生错误。</p><p>意向锁除了全表请求外不阻止任何操作（例如，<a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES ... WRITE</code></a>）。意向锁主要的目的是表明某人（someone）正锁定或将要锁定表中的行。</p><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html" target="_blank" rel="noopener">InnoDB监视器</a>输出中，意向锁的事务数据看起来类似以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TABLE LOCK table `test`.`t` trx id 10080 lock mode IX</span><br></pre></td></tr></table></figure><h2 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h2><p>记录锁是在索引记录上的一个锁。例如，<code>SELECT C! FROM t WHERE c1 = 10 FOR UPDATE;</code>防止其他事务插入，更新或删除<code>t.c1</code>的值为<code>10</code>的行。</p><p>记录锁总是锁定索引记录，即使没有定义索引的表。对于这种情况，<code>InnoDB</code>创建一个隐藏的聚簇索引，并将改索引用于记录锁。查看<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html" target="_blank" rel="noopener">Section 15.6.2.1，“聚簇索引和二级索引”</a></p><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html" target="_blank" rel="noopener">InnoDB监视器</a>输出中，记录锁的事务数据看起来类似以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` </span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &apos;O;;</span><br><span class="line">2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure><h2 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h2><p>间隙锁是在索引数据之间的间隙的锁定，或在第一个索引记录之前或最后一个索引记录之后的间隙的锁定。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>会防止其他事务将<code>15</code>插入到<code>t.c1</code>列中，无论该列中是否已经有这样的值，因为该范围的所有现有值之间的间隙是被锁定的。</p><p>间隙可能跨越单个索引值，多个索引值，甚至为空。</p><p>间隙锁是在性能和并发性之间权衡的一部分，并且在某些事务隔离级别而非其他级别使用。</p><p>对于使用唯一索引锁行来搜索唯一行的语句不需要间隙锁。（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这个情况下，会发生间隙锁定。）例如，假如<code>id</code>列有个唯一索引，以下语句进队<code>id</code>值为100的行使用记录锁，并且其他会话在前间隙插入行也是没关系的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM child WHERE id = 100;</span><br></pre></td></tr></table></figure><p>如果<code>id</code>没有索引或有非唯一索引，则该语句会锁定前间隙。</p><p>值得注意的是，可以通过不同事务将冲突的锁能保持在间隙上。例如，事务A在间隙上保留一个共享间隙锁（gap S-lock），而事务B在同个间隙上保留排他间隙锁（gap X-lock）。允许冲突间隙锁的原因是，如果从索引中清除记录，必须合并有不同事务上在记录上保留的间隙锁。</p><p><code>InnoDB</code>中间隙锁是“完全抑制的（purely inhibitive）”，这意味着它们的目的是阻止其他事务插入间隙。间隙锁是可以共存的。一个间隙锁被一个事务获取不会阻止其他事务在同个间隙获取间隙锁。共享和排他间隙锁没有区别。它们不互相冲突，并且执行相同的功能。</p><p>间隙锁能被直接禁用。如果你将事务隔离级别修改为<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener">已提交读（READ COMMITED）</a>。在这种情况下，间隙锁在搜索和索引扫描是被禁用的，仅用于外键约束检查和重复键检查。</p><p>使用<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener">已提交读（READ COMMITED）</a>的隔离级别还有其他影响。MySQL评估<code>WHERE</code>条件后，不匹配的记录锁将会被释放。对于<code>UPDATE</code>语句，<code>InnoDB</code>进行“半一致（semi-consistent）”读。它会返回最后提交版本给MySQL，以便MySQL可以确定该行是否与<a href="https://dev.mysql.com/doc/refman/8.0/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>的<code>WHERE</code>条件匹配。</p><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>Next-Key锁是索引记录上的记录锁和索引记录之前间隙上的间隙锁的组合。</p><p><code>InnoDB</code>执行行级锁的方式是，当它搜索或扫描表索引时，会在遇到的索引上设置共享或排他锁。从而，行级锁实际上是索引记录锁。在索引记录上的next-key锁也能影响该索引记录之前“间隙”。那就是，next-key锁是一个索引记录锁加上在索引记录之前间隙的间隙锁。假如一个会话在记录<code>R</code>上有一个共享或者排他锁，另一个会话不能按照索引顺序在<code>R</code>之前间隙中插入一条新索引记录。</p><p>假设一个索引包含了值10，11，13和20。该索引的next-key锁可能覆盖以下区间，其中，圆括号表示排除区间端点，方括号标段包含端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><p>最后的区间，next-key锁锁了索引的最大值之后的间隙以及“最高（supremum）”伪记录（pseudo-record）的值高于实际在索引的任何值。最高（The supremum）不是一个真实的索引记录，所以，实际上，这个next-key锁只锁最大索引值之后的间隙。</p><p>默认情况下，<code>InnoDB</code>运行在<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener">可重复读（REPEATABLE READ）</a>的事务隔离级别下。这种情况下，<code>InnoDB</code>使用next-key锁进行搜索和索引扫描，从而防止了幻象行（phantom row）（查看<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html" target="_blank" rel="noopener">Section 15.7.4，”Phantom Rows”</a>)</p><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html" target="_blank" rel="noopener">InnoDB监视器</a>输出中，next-key锁的事务数据看起来类似以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` </span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">1</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">1</span>; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">3</span>; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     'O;;</span><br><span class="line">2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure><h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><p>插入意向锁是一种在行插入之前通过<a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener">INSERT</a>操作设置的间隙锁。如果插入到同一索引间隙的多个事务不在间隙中的相同位置插入，则此锁表示希望以这样的一种方式进行插入，即插入到同一索引间隙的多个事务无需相互等待。假设，有索引记录的值为4和7。尝试插入值5和6的单个事务，分别在获得插入行的排他锁之前，每一个事务先用插入意向锁来锁定4和7之间的间隙，但是由于行是没有冲突的，所以彼此不会阻塞。</p><p>下列示例展示了事务在插入记录上获取排他锁之前获取插入意图锁。这个例子包含了两个客户端，A和B。</p><p>客户端A创建包含两个索引记录（90和102）的表，接着开始一个事务，在ID大于100的索引记录上放置一个排他锁。这个排他锁包含了记录102之前的间隙锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;</span><br><span class="line">mysql&gt; INSERT INTO child (id) values (90),(102);</span><br><span class="line"></span><br><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</span><br><span class="line">+-----+</span><br><span class="line">| id  |</span><br><span class="line">+-----+</span><br><span class="line">| 102 |</span><br><span class="line">+-----+</span><br></pre></td></tr></table></figure><p>客户端B开启一个事务，插入一个记录到间隙中。这个事务在等待获取一个排他锁时获取了一个插入意图锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; INSERT INTO child (id) VALUES (101);</span><br></pre></td></tr></table></figure><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html" target="_blank" rel="noopener">InnoDB监视器</a>输出中，插入意图锁的事务数据看起来类似以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`</span><br><span class="line">trx id 8731 lock_mode X locks gap before rec <span class="keyword">insert</span> intention waiting</span><br><span class="line"><span class="built_in">Record</span> <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">3</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">3</span>; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000066; asc    f;;</span><br><span class="line"> 1: len 6; hex 000000002215; asc     " ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure><h2 id="自增锁（AUTO-INC-Locks）"><a href="#自增锁（AUTO-INC-Locks）" class="headerlink" title="自增锁（AUTO-INC Locks）"></a>自增锁（AUTO-INC Locks）</h2><p>自增锁是一种特殊的表级锁，由事务插入具有<code>AUTO_INCREMENT</code>列的表中获得。在最简单的情况中，如果一个事务正在表中插入数据，任意其他事务必须等待执行自己插入操作，因此，第一个事务插入的行将收到联系的主键值。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode" target="_blank" rel="noopener"><code>innodb_autoinc_lock_mode</code></a>配置选项用于控制自增锁定的算法。它允许你选择如何在可预测的自增值和插入操作的最大并发性之间权衡。</p><p>更多信息，查看 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">Section 15.6.1.6，“AUTO_INCREMENT Handing in InnoDB”</a></p><h2 id="空间索引的谓词锁"><a href="#空间索引的谓词锁" class="headerlink" title="空间索引的谓词锁"></a>空间索引的谓词锁</h2><p><code>InnoDB</code>支持包含空间列（spatial columns）的<code>空间（SPATIAL）</code>索引。（查看 <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-spatial-analysis.html" target="_blank" rel="noopener">Section 11.4.8，“Optimizing Spatial Analysis”</a>）。</p><p>为了处理涉及<code>空间（SPATIAL）</code>索引操作的锁定，next-key锁不能很好地支持<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener"><code>REPEATABLE READ</code></a>或<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener"><code>SERIALIZABLE</code></a>事务隔离级别。多维数据中没有绝对排序概念，因此不清楚哪一个是“下一个”键。</p><p>为了支持具有<code>空间（SPATIAL）</code>索引的表的隔离级别。<code>InnoDB</code>使用了谓词锁。<code>空间（SPATIAL）</code>索引包含了最小边界矩形（MBR）值，因此<code>InnoDB</code>通过在用于查询的MBR值上设置谓词锁来强制对索引进行一致的读取。其他事务不能插入或修改匹配查询条件的行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/InnoDB-Locking-Translation/69174779_p0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻译文档地址：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;共享锁与排他锁（Shared-and-Exclusive-Locks）&quot;&gt;&lt;a href=&quot;#共享锁与排他锁（Shared-and-Exclusive-Locks）&quot; class=&quot;headerlink&quot; title=&quot;共享锁与排他锁（Shared and Exclusive Locks）&quot;&gt;&lt;/a&gt;共享锁与排他锁（Shared and Exclusive Locks）&lt;/h2&gt;&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;实现了标准行锁定，其中有两种类型锁：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;共享（&lt;code&gt;S&lt;/code&gt;）锁&lt;/a&gt; 和 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;排他（&lt;code&gt;X&lt;/code&gt;）锁&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;共享锁&lt;/a&gt;允许持有该锁的事务读取一行。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;排他锁&lt;/a&gt;允许持有该所的事务更新或删除一行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如事务&lt;code&gt;T1&lt;/code&gt;在行&lt;code&gt;r&lt;/code&gt;上持有共享（&lt;code&gt;S&lt;/code&gt;）锁，然后，不同的事务&lt;code&gt;T2&lt;/code&gt;请求行&lt;code&gt;r&lt;/code&gt;上的锁时，处理方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T2&lt;/code&gt;对&lt;code&gt;S&lt;/code&gt;锁的请求会被立即同意（granted immediately）。结果是，&lt;code&gt;T1&lt;/code&gt;和&lt;code&gt;T2&lt;/code&gt;在&lt;code&gt;r&lt;/code&gt;上都将持有&lt;code&gt;S&lt;/code&gt;锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T2&lt;/code&gt;对&lt;code&gt;X&lt;/code&gt;锁的请求不会被立即同意。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果事务&lt;code&gt;T1&lt;/code&gt;持有对行&lt;code&gt;r&lt;/code&gt;的排他（&lt;code&gt;X&lt;/code&gt;）锁，来自不同事务&lt;code&gt;T2&lt;/code&gt;的请求&lt;code&gt;r&lt;/code&gt;上的两种类型的锁都不会被立即同意。反而，事务&lt;code&gt;T2&lt;/code&gt;必须等待事务&lt;code&gt;T1&lt;/code&gt;释放对行&lt;code&gt;r&lt;/code&gt;的锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="InnoDB" scheme="https://mikado.drrr.app/tags/InnoDB/"/>
    
      <category term="MySQL" scheme="https://mikado.drrr.app/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>哈希冲突</title>
    <link href="https://mikado.drrr.app/Hash-Collisions/"/>
    <id>https://mikado.drrr.app/Hash-Collisions/</id>
    <published>2020-03-01T14:39:11.000Z</published>
    <updated>2020-04-06T14:36:52.579Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Hash-Collisions/b32662efc5800fdcd75e0e9205072772.jpg" alt=""></p><h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><p>在有限的数组存储空间中，不存在一个Hash函数是能完全避免Hash冲突的。</p><h2 id="Hash-冲突"><a href="#Hash-冲突" class="headerlink" title="Hash 冲突"></a>Hash 冲突</h2><p>发生了Hash冲突，解决方法有两种，开放寻址法（Open addressing）和链表法(Chaining)。</p><a id="more"></a><ul><li>开放寻址法</li></ul><p>开放寻址法的核心思想是，出现了Hash冲突就重新找空闲的位置，将其插入。一个简单的探测方法就是<strong>线性探测</strong>（Linear Probing)。</p><p>图例：</p><p><img src="/images/Hash-Collisions/Hash-Collisions-Open-Addressing-Linear-Probing-Example.jpg" alt=""></p><p>从图中可以看出，被Hash函数计算出的位置已经有数据存在了，就往下一位放，如果到底都无法插入，就从头开始找。</p><p>这个方法的删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。假如有一个Hash冲突后的数据，要查找是否存在，通过线性探测计算出空闲位置，但是空闲位置上的数据为之前删除的，就会认定不存在。导致查找结果失败。</p><p>解决方法就是设置个特殊标记，标为这个数据为删除的。</p><p>除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重Hash</strong>（Double hashing）。</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2……</p><p>双重Hash，就是不仅要使用一个Hash函数。使用一组Hash函数，hash1、hash2、hash3……使用第一个Hash函数（hash1），计算出位置，结果不为空，就用第二个Hash函数（hash2），依次类推。</p><p>不管采用哪种探测方法，当Hash表中空闲位置不多的时候，Hash冲突的概率就会大大提高。为了尽可能保证Hash表的操作效率，一般情况下，我们会尽可能保证Hash表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p><p>装载因子的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash表的装载因子 = 填入表中的元素个数 / Hash表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，Hash表的性能会下降…对于开放定址法，装载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了装载因子为0.75，超过此值将resizeHash表。</p><ul><li>链表法</li></ul><p>链表法是比较常用的hash冲突解决方法。在Hash表中，每个“桶（Bucket）”或者“槽（Slot）”会对应一个列表</p><p>在插入的时候，计算出位置，如果位置不为空，则会插入到桶的链表中。</p><p>图例：</p><p><img src="/images/Hash-Collisions/Hash-Collisions-Chaining-Example.jpg" alt=""></p><h2 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h2><p>装载因子是表示Hsah表中元素的填满的程度，该值越大，说明Hash表中的元素越多，空闲的位置越少，Hash冲突的概率越大。不仅插入数据的过程要多次寻址或者拉很长的链表，查找过程也会因此变得很慢。</p><p>对于动态Hash表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我也无法去事先申请一个足够大的Hash表。随者数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，Hash冲突就会变得不可接受。</p><p>这个时候就需要对Hash表“动态扩容”了。针对Hash表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的Hash表，将数据搬移到新Hash表中。假设每次扩容我们都申请一个原来Hash表大小两倍的空间。如果原来Hash表的装载因子是0.8，那经过扩容之后，新Hash表的装载因子就下降为原来的一半，变成了0.4.针对数组的扩容，数据搬移操作比较简单。但是，针对Hash表的扩容，数据搬移操作要复杂很多。因为Hash表的大小变了，数据的存储位置也变了，所以我们需要通过Hash函数重新计算每个数据的存储位置。</p><p>Hash表数据不多时，数据搬移操作基本不费时间和空间，但是如果数据量很大时，搬移操作就很耗时耗空间。</p><p>解决方法是：一个新数据进来时，申请一个新的Hash表，并计算位置插入到新的Hash表。旧的Hash表数据不变。再有新的数据进来时，插入到新的Hash表，并拿旧Hash表的一个数据计算在新的Hash表中的位置并插入，重复上述过程，旧Hash表的数据就一点点的到新的Hash表中。</p><p>上述解决方法的查询顺序就是现在新的Hash表中查找，如果不存在再去旧的Hash表中查找，如果再没有，就是不存在了。</p><h2 id="如何选择Hash冲突解决方法？"><a href="#如何选择Hash冲突解决方法？" class="headerlink" title="如何选择Hash冲突解决方法？"></a>如何选择Hash冲突解决方法？</h2><ul><li>开放寻址法</li></ul><p>由于开放寻址法删除数据比较麻烦，需要标记已删除数据。在开放寻址法中，所有数据都放在一个数组里，比起链表法，开放寻址法的冲突代价更高。</p><p>所以当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java 中的ThreadLocalMap使用开放寻址法解决Hash冲突的原因。</p><ul><li>链表法</li></ul><p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</p><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的Hash冲突，致大量的探测、再Hash等，性能会下降很多。但是对于链表法来说，只要Hash函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已。虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Hash-Collisions/b32662efc5800fdcd75e0e9205072772.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Hash-函数&quot;&gt;&lt;a href=&quot;#Hash-函数&quot; class=&quot;headerlink&quot; title=&quot;Hash 函数&quot;&gt;&lt;/a&gt;Hash 函数&lt;/h2&gt;&lt;p&gt;在有限的数组存储空间中，不存在一个Hash函数是能完全避免Hash冲突的。&lt;/p&gt;
&lt;h2 id=&quot;Hash-冲突&quot;&gt;&lt;a href=&quot;#Hash-冲突&quot; class=&quot;headerlink&quot; title=&quot;Hash 冲突&quot;&gt;&lt;/a&gt;Hash 冲突&lt;/h2&gt;&lt;p&gt;发生了Hash冲突，解决方法有两种，开放寻址法（Open addressing）和链表法(Chaining)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hash" scheme="https://mikado.drrr.app/tags/hash/"/>
    
      <category term="Data Struct" scheme="https://mikado.drrr.app/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>TCP-协议</title>
    <link href="https://mikado.drrr.app/TCP-Protocol/"/>
    <id>https://mikado.drrr.app/TCP-Protocol/</id>
    <published>2019-08-29T14:30:18.000Z</published>
    <updated>2019-08-29T14:54:12.668Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/TCP-Protocol/a15b4afegy1fmviz5449mj21hc0u01kx.jpg" alt=""></p><h2 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h2><ul><li>TCP 提供一种面向连接的、可靠的字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p><a id="more"></a><h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p><ul><li><p>第一次握手(SYN=1, seq=x)</p><p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 SYN_SEND 状态。</p></li><li><p>第二次握手(SYN=1, ACK=1, seq=y,  ACKnum=x+1)</p><p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p></li><li><p>第三次握手(ACK=1，ACKnum=y+1)</p><p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p><p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p></li></ul><p>三次握手的过程的示意图如下：</p><p><img src="/images/TCP-Protocol/tcp-connection-made-three-way-handshake.png" alt="three-way-handshake"></p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p></li><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p></li><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</p></li><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p></li></ul><p>四次挥手的示意图如下：</p><p><img src="/images/TCP-Protocol/tcp-connection-closed-four-way-handshake.png" alt="four-way-handshake"></p><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul><li><p>什么是 SYN 攻击（SYN Flood）？</p><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p></li><li><p>如何检测 SYN 攻击？</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p></li><li><p>如何防御 SYN 攻击？</p><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul></li></ul><h2 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h2><p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。</p><p>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><p><a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">TCP-Keepalive-HOWTO</a> 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/TCP-Protocol/a15b4afegy1fmviz5449mj21hc0u01kx.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;TCP-的特性&quot;&gt;&lt;a href=&quot;#TCP-的特性&quot; class=&quot;headerlink&quot; title=&quot;TCP 的特性&quot;&gt;&lt;/a&gt;TCP 的特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP 提供一种面向连接的、可靠的字节流服务&lt;/li&gt;
&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP&lt;/li&gt;
&lt;li&gt;TCP 使用校验和，确认和重传机制来保证可靠传输&lt;/li&gt;
&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复&lt;/li&gt;
&lt;li&gt;TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TCP" scheme="https://mikado.drrr.app/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化介绍</title>
    <link href="https://mikado.drrr.app/Redis-Persistence/"/>
    <id>https://mikado.drrr.app/Redis-Persistence/</id>
    <published>2019-02-21T09:59:51.000Z</published>
    <updated>2019-08-29T14:49:51.575Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Redis-Persistence/a15b4afegy1fmvjboz2dgj21hc0u0qj6.jpg" alt=""></p><blockquote><p>EN：<a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">https://redis.io/topics/persistence</a> <br>CN：<a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">http://www.redis.cn/topics/persistence.html</a></p></blockquote><h3 id="Redis-提供了不同级别的持久化方式"><a href="#Redis-提供了不同级别的持久化方式" class="headerlink" title="Redis 提供了不同级别的持久化方式:"></a>Redis 提供了不同级别的持久化方式:</h3><p><code>RDB</code> 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p><ul><li><code>AOF</code> 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, <code>AOF</code> 命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对 <code>AOF</code> 文件进行后台重写,使得 <code>AOF</code> 文件的体积不至于过大.</li><li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入 <code>AOF</code> 文件来恢复原始的数据,因为在通常情况下 <code>AOF</code> 文件保存的数据集要比 <code>RDB</code> 文件保存的数据集要完整.</li><li>最重要的事情是了解 <code>RDB</code> 和 <code>AOF</code> 持久化方式的不同,让我们以 <code>RDB</code> 持久化方式开始：<a id="more"></a></li></ul><h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a><code>RDB</code>优点</h3><ul><li><code>RDB</code> 持久化保存一个时间点的Redis数据</li><li><code>RDB</code> 适合容灾恢复</li><li><code>RDB</code> 最大限度地提高了Redis的性能</li><li>与 <code>AOF</code> 相比， <code>RDB</code> 允许使用大数据集更快地重启。</li></ul><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a><code>RDB</code>缺点</h3><ul><li>意外情况发生，数据会有丢失</li><li><code>RDB</code> 需要<code>fork()</code>出子进程来处理持久化，如果数据集比较大，<code>fork()</code>会很耗时的。再加上CPU性能也不是很好，耗时就会很久。 <code>AOF</code> 也是需要<code>fork()</code>的，但是 <code>AOF</code> 能调整重写无需权衡持久性的日志的频率</li></ul><h3 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a><code>AOF</code> 优点</h3><ul><li><code>AOF</code> 有多种<code>fsync</code>策略（NO <code>fsync</code>,每秒<code>fsync</code>，每个查询<code>fsync</code>）。默认的每秒<code>fsync</code>策略，写性能也是不错的（<code>fsync</code>是使用后台线程执行的，当没有<code>fsync</code>正在进行时主线程会尽力执行写操作）</li><li><code>AOF</code> 的日志的append的，所以发生意外时，使用<code>redis-check-aof</code> 工具还是能简单的修复</li><li>当Redis太大时，Redis会在后台自动重写 <code>AOF</code> 日志。重写是完全安全的，因为当Redis继续附加到旧文件时，使用创建当前数据集所需的最小操作集生成一个全新的文件，并一旦第二个文件准备就绪，Redis会切换两个并开始附加到 新的那一个。</li><li><code>AOF</code> 包含所有便于理解格式的操作日志，你可以轻松导入一个 <code>AOF</code> 文件。万一使用了<code>FLUSHALL</code>，还是能通过 <code>AOF</code> 文件恢复的。</li></ul><h3 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a><code>AOF</code> 缺点</h3><ul><li>文件比 <code>RDB</code> 大</li><li>精确<code>fsync</code>策略的话，<code>AOF</code> 比较慢。禁用<code>fsync</code>的话，跟 <code>RDB</code> 差不多快</li></ul><h3 id="快照（Snapshotting）"><a href="#快照（Snapshotting）" class="headerlink" title="快照（Snapshotting）"></a>快照（Snapshotting）</h3><p>默认的数据集快照是保存到磁盘的，一个叫 <code>dump.rdb</code>  的二进制文件。你可以配置在N秒内至少M次修改时保存快照。有两个命令 <code>SAVE</code> 和<code>BGSAVE</code>。例子，60秒内有1000key改动：<code>save 60 1000</code></p><h3 id="快照是怎么工作的（How-it-works"><a href="#快照是怎么工作的（How-it-works" class="headerlink" title="快照是怎么工作的（How it works)"></a>快照是怎么工作的（How it works)</h3><ul><li>Redis执行<code>fork</code>操作，现在有一个子进程和一个父进程。</li><li>子进程开始把数据集写入临时的 <code>RDB</code> 文件</li><li>当子进程完成写入新的 <code>RDB</code> 文件，就会替换掉旧的文件</li></ul><h3 id="附加文件（Append-only-file）"><a href="#附加文件（Append-only-file）" class="headerlink" title="附加文件（Append-only file）"></a>附加文件（Append-only file）</h3><p>快照不是非常耐用（durable）。如果发生意外（Redis停止，断电，<code>kill -9</code>），最后的Redis数据就会丢失。在1.1版本后，你可以在配置文件中开启 <code>AOF</code> ：<code>appendonly file</code>。现在开始，每次Redis接收到命令将会附加到 <code>AOF</code> 中。当Redis重启时，Redis会自己根据 <code>AOF</code> 文件重建状态。</p><h3 id="日记重写（Log-rewriting）"><a href="#日记重写（Log-rewriting）" class="headerlink" title="日记重写（Log rewriting）"></a>日记重写（Log rewriting）</h3><p><code>AOF</code> 会根据执行越来越大。例如，如果将一个计数器递增100次，则最终会在数据集中包含一个包含最终值的key，但在 <code>AOF</code> 中会有100个条目。重建当前状态其实不需要其中99个条目。在Redis 2.2中有 <code>BGREWRITEAOF</code>  这个命令，这个会分析出重建当前数据集所需最短的命令。在Redis 2.4之后就会自动执行（更多信息需要看配置文件）。</p><h3 id="AOF-的持久性如何？（How-durable-is-the-append-only-file"><a href="#AOF-的持久性如何？（How-durable-is-the-append-only-file" class="headerlink" title="AOF 的持久性如何？（How durable is the append only file?)"></a><code>AOF</code> 的持久性如何？（How durable is the append only file?)</h3><p><code>AOF</code> 有三种配置来配置备份频率</p><ul><li>每个命令都<code>fsync</code>备份。非常非常慢，但是非常安全。</li><li>每秒<code>fsync</code>备份。如果发送意外，最多也就丢失1s的数据</li><li>不<code>fsync</code>备份。<br><code>AOF</code> 默认是第二个(每秒<code>fsync</code>备份)。</li></ul><h3 id="如果-AOF-文件损坏怎么处理"><a href="#如果-AOF-文件损坏怎么处理" class="headerlink" title="如果 AOF 文件损坏怎么处理"></a>如果 <code>AOF</code> 文件损坏怎么处理</h3><ul><li>备份你的 <code>AOF</code> 文件</li><li>使用Redis自带的<code>redis-check-aof</code>工具。 <code>$ redis-check-aof --fix</code></li><li>(可选)使用 <code>diff -u</code> 来查看两个文件的不同</li><li>使用修复后的文件重启Redis服务服务器</li></ul><h3 id="怎么修复的？"><a href="#怎么修复的？" class="headerlink" title="怎么修复的？"></a>怎么修复的？</h3><ul><li>Redis执行<code>fork</code>操作，现在有一个子进程和一个父进程。</li><li>子进程开始写新的 <code>AOF</code> 到临时文件</li><li>父进程把所有新的改动缓存到内存缓冲区（in-memory buffer）（同时也会把新的改动append到旧的 <code>AOF</code> 文件）。</li><li>当子进程完成后，父进程得到一个信号，开始将内存缓冲区的数据append到新的 <code>AOF</code> 文件中</li><li>Redis会进行原子性的重命名，将临时文件重命名为新的。并开始appending旧的数据。</li></ul><h3 id="怎么从-RDB-切换到-AOF"><a href="#怎么从-RDB-切换到-AOF" class="headerlink" title="怎么从 RDB 切换到 AOF"></a>怎么从 <code>RDB</code> 切换到 <code>AOF</code></h3><p>在Redis 2.2之后有不同的操作方式</p><p><em>Redis &gt;= 2.2</em></p><ul><li>备份最新的<code>dump.rdb</code>文件，并移动到安全的地方。</li><li>发送两个命令 <code>redis-cli config set appendonly yes</code> 和 <code>redis-cli config set save &quot;&quot;</code>。</li><li>确保写命令会被正确地追加到  <code>AOF</code>  文件的末尾。</li><li>执行的第一条命令开启了 <code>AOF</code> 功能： Redis 会阻塞直到初始 <code>AOF</code> 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 <code>AOF</code>  文件末尾。</li></ul><p>执行的第二条命令用于关闭 <code>RDB</code> 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 <code>RDB</code> 和 <code>AOF</code> 这两种持久化功能。</p><p><strong>重要</strong>:别忘了在 <code>redis.conf</code> 中打开 <code>AOF</code> 功能！ 否则的话， 服务器重启之后， 之前通过 <code>CONFIG SET</code> 设置的配置就会被失效，程序会按原来的配置来启动服务器</p><p><em>Redis 2.0</em></p><ul><li>备份最新的<code>dump.rdb</code> 文件，并移动到安全的地方</li><li>停止写入。</li><li>执行 <code>redis-cli bgrewriteaof</code>， 这个会创建 <code>AOF</code> 文件。</li><li>生成完 <code>AOF</code> 文件就停止Redis服务器。</li><li><code>redis.conf</code>中开启 <code>AOF</code> 持久化。</li><li>重启Redis服务器。</li><li>确保您的数据库包含相同数量的Key。</li><li>确保写入正确附加到 <code>AOF</code> 文件。</li></ul><h3 id="AOF-和-RDB-之间的相互作用"><a href="#AOF-和-RDB-之间的相互作用" class="headerlink" title="AOF 和 RDB 之间的相互作用"></a><code>AOF</code> 和 <code>RDB</code> 之间的相互作用</h3><p>在版本号大于等于 2.4 的 Redis 中，<code>BGSAVE</code> 执行的过程中，不可以执行 <code>BGREWRITEAOF</code> 。反过来说，在 <code>BGREWRITEAOF</code> 执行的过程中， 也不可以执行 <code>BGSAVE</code>。这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p><p>如果 <code>BGSAVE</code> 正在执行， 并且用户显示地调用 <code>BGREWRITEAOF</code> 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户，<code>BGREWRITEAOF</code> 已经被预定执行： 一旦 <code>BGSAVE</code> 执行完毕，<code>BGREWRITEAOF</code> 就会正式开始。 当 Redis 启动时， 如果 <code>RDB</code> 持久化和 <code>AOF</code> 持久化都被打开了， 那么程序会优先使用  <code>AOF</code> 文件来恢复数据集， 因为 <code>AOF</code> 文件所保存的数据通常是最完整的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Redis-Persistence/a15b4afegy1fmvjboz2dgj21hc0u0qj6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EN：&lt;a href=&quot;https://redis.io/topics/persistence&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://redis.io/topics/persistence&lt;/a&gt; &lt;br&gt;CN：&lt;a href=&quot;http://www.redis.cn/topics/persistence.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/topics/persistence.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Redis-提供了不同级别的持久化方式&quot;&gt;&lt;a href=&quot;#Redis-提供了不同级别的持久化方式&quot; class=&quot;headerlink&quot; title=&quot;Redis 提供了不同级别的持久化方式:&quot;&gt;&lt;/a&gt;Redis 提供了不同级别的持久化方式:&lt;/h3&gt;&lt;p&gt;&lt;code&gt;RDB&lt;/code&gt; 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AOF&lt;/code&gt; 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, &lt;code&gt;AOF&lt;/code&gt; 命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对 &lt;code&gt;AOF&lt;/code&gt; 文件进行后台重写,使得 &lt;code&gt;AOF&lt;/code&gt; 文件的体积不至于过大.&lt;/li&gt;
&lt;li&gt;如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.&lt;/li&gt;
&lt;li&gt;你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入 &lt;code&gt;AOF&lt;/code&gt; 文件来恢复原始的数据,因为在通常情况下 &lt;code&gt;AOF&lt;/code&gt; 文件保存的数据集要比 &lt;code&gt;RDB&lt;/code&gt; 文件保存的数据集要完整.&lt;/li&gt;
&lt;li&gt;最重要的事情是了解 &lt;code&gt;RDB&lt;/code&gt; 和 &lt;code&gt;AOF&lt;/code&gt; 持久化方式的不同,让我们以 &lt;code&gt;RDB&lt;/code&gt; 持久化方式开始：
    
    </summary>
    
    
      <category term="Linux" scheme="https://mikado.drrr.app/tags/Linux/"/>
    
      <category term="Redis" scheme="https://mikado.drrr.app/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu服务器安装</title>
    <link href="https://mikado.drrr.app/Ubuntu-Server-Install-Note/"/>
    <id>https://mikado.drrr.app/Ubuntu-Server-Install-Note/</id>
    <published>2019-01-31T02:07:09.000Z</published>
    <updated>2019-08-29T14:50:31.877Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Ubuntu-Server-Install-Note/0072Vf1pgy1foxk73gascj31hc0u07e1.jpg" alt=""></p><p>This is a note when I installing Ubuntu 18.04 LTS Server. </p><h2 id="Before-install"><a href="#Before-install" class="headerlink" title="Before install"></a>Before install</h2><h3 id="Change-SSH-port"><a href="#Change-SSH-port" class="headerlink" title="Change SSH port"></a>Change SSH port</h3><ol><li>Edit ssh config</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ol start="2"><li>Change port</li><li>Restart sshd service</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Add-user"><a href="#Add-user" class="headerlink" title="Add user"></a>Add user</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /bin/bash &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="Edit-visudo"><a href="#Edit-visudo" class="headerlink" title="Edit visudo"></a>Edit visudo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><ul><li>if <code>visudo</code> is using <code>nano</code>, you can use <code>update-alternatives --config editor</code> chage default editor.</li></ul><h3 id="Set-up-user-password"><a href="#Set-up-user-password" class="headerlink" title="Set up user password"></a>Set up user password</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-user"><a href="#Change-user" class="headerlink" title="Change user"></a>Change user</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="Update-sources-mirror"><a href="#Update-sources-mirror" class="headerlink" title="Update sources mirror"></a>Update sources mirror</h3><blockquote><p><a href="https://mirrors.ustc.edu.cn/help/ubuntu.html" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/help/ubuntu.html</a></p></blockquote><ol><li>Back up sources list</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><ol start="2"><li>Has two way to update sources list.</li></ol><ul><li>If you using English, the <code>&lt;country-code&gt;</code> is empty.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i 's/&lt;country-code&gt;.archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list</span><br></pre></td></tr></table></figure><ul><li>Edit <code>/etc/apt/sources.list</code>, need <code>sudo</code>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认注释了源码仓库，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 预发布软件源，不建议启用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><h3 id="Update-system"><a href="#Update-system" class="headerlink" title="Update system"></a>Update system</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="Install-develop-tool"><a href="#Install-develop-tool" class="headerlink" title="Install develop tool"></a>Install develop tool</h2><p><strong>Not root!!!</strong></p><h3 id="Vimrc-config"><a href="#Vimrc-config" class="headerlink" title="Vimrc config"></a>Vimrc config</h3><p>edit <code>~/.vimrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set number</span><br><span class="line">syntax on</span><br></pre></td></tr></table></figure><h3 id="PHP-7-2"><a href="#PHP-7-2" class="headerlink" title="PHP 7.2"></a>PHP 7.2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.2 php7.2-mysql php7.2-curl \</span><br><span class="line">    php7.2-common php7.2-xml php7.2-json \</span><br><span class="line">    php7.2-cli php7.2-bcmath php7.2-fpm \</span><br><span class="line">    php7.2-mbstring</span><br></pre></td></tr></table></figure><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><ul><li>Install composer</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"</span><br><span class="line">php -r "if (hash_file('sha384', 'composer-setup.php') === '93b54496392c062774670ac18b134c3b3a95e5a5e5c8f1a9f115f203b75bf9a129d5daa8ba6a13e2cc8a1da0806388a8') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php');&#125; echo PHP_EOL;"</span><br><span class="line">php composer-setup.php</span><br><span class="line">php -r "unlink('composer-setup.php');"</span><br><span class="line">sudo cp composer.phar /user/bin/composer</span><br></pre></td></tr></table></figure><ul><li>Set up composer packagist url</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.laravel-china.org</span><br></pre></td></tr></table></figure><h3 id="MariaDB-10-4"><a href="#MariaDB-10-4" class="headerlink" title="MariaDB-10.4"></a>MariaDB-10.4</h3><h4 id="Install-mariadb-server"><a href="#Install-mariadb-server" class="headerlink" title="Install mariadb server"></a>Install mariadb server</h4><blockquote><p><a href="https://downloads.mariadb.org/mariadb/repositories" target="_blank" rel="noopener">https://downloads.mariadb.org/mariadb/repositories</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8</span><br><span class="line">sudo add-apt-repository 'deb [arch=amd64,arm64,ppc64el] https://mirrors.shu.edu.cn/mariadb/repo/10.4/ubuntu bionic main'</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install mariadb-server</span><br></pre></td></tr></table></figure><h4 id="Add-user-1"><a href="#Add-user-1" class="headerlink" title="Add user"></a>Add user</h4><blockquote><p><a href="https://mariadb.com/kb/en/library/create-user/" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/create-user/</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">USER</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="string">'foo2'</span>@<span class="string">'test'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure><h4 id="Grant-user"><a href="#Grant-user" class="headerlink" title="Grant user"></a>Grant user</h4><blockquote><p><a href="https://mariadb.com/kb/en/library/grant" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/grant</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL ON laravel_blog.* TO 'laravel_blog'@'%'</span><br></pre></td></tr></table></figure><h4 id="Change-port"><a href="#Change-port" class="headerlink" title="Change port"></a>Change port</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Ubuntu-Server-Install-Note/0072Vf1pgy1foxk73gascj31hc0u07e1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;This is a note when I installing Ubuntu 18.04 LTS Server. &lt;/p&gt;
&lt;h2 id=&quot;Before-install&quot;&gt;&lt;a href=&quot;#Before-install&quot; class=&quot;headerlink&quot; title=&quot;Before install&quot;&gt;&lt;/a&gt;Before install&lt;/h2&gt;&lt;h3 id=&quot;Change-SSH-port&quot;&gt;&lt;a href=&quot;#Change-SSH-port&quot; class=&quot;headerlink&quot; title=&quot;Change SSH port&quot;&gt;&lt;/a&gt;Change SSH port&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Edit ssh config&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo vim /etc/ssh/sshd_config&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Change port&lt;/li&gt;
&lt;li&gt;Restart sshd service&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service sshd restart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://mikado.drrr.app/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://mikado.drrr.app/tags/Ubuntu/"/>
    
      <category term="Linux Server" scheme="https://mikado.drrr.app/tags/Linux-Server/"/>
    
  </entry>
  
  <entry>
    <title>Tmux和Zsh的安装与配置</title>
    <link href="https://mikado.drrr.app/Tmux-And-ZSH-Install-And-Configuration/"/>
    <id>https://mikado.drrr.app/Tmux-And-ZSH-Install-And-Configuration/</id>
    <published>2019-01-27T13:08:54.000Z</published>
    <updated>2019-08-29T14:52:18.062Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Tmux-And-ZSH-Install-And-Configuration/a15b4afegy1fnokpqcv02j21hc0u0jux.jpg" alt=""></p><p>记录 Linux (Ubuntu 18.04 LTS) 下装 Tmux 和 Zsh 的过程<a id="more"></a></p><h2 id="安装Tmux和Zsh"><a href="#安装Tmux和Zsh" class="headerlink" title="安装Tmux和Zsh"></a>安装Tmux和Zsh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update </span><br><span class="line">sudo apt install tmux zsh</span><br></pre></td></tr></table></figure><h2 id="配置Zsh"><a href="#配置Zsh" class="headerlink" title="配置Zsh"></a>配置Zsh</h2><h3 id="安装Oh-My-Zsh"><a href="#安装Oh-My-Zsh" class="headerlink" title="安装Oh-My-Zsh"></a>安装Oh-My-Zsh</h3><blockquote><p>具体内容可以查看<a href="https://ohmyz.sh/" target="_blank" rel="noopener">官网</a></p></blockquote><ul><li>使用 <code>curl</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>wget</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>使用的插件有 <code>zsh-syntax-highlighting</code>，<code>zsh-autosuggestions</code>，<code>autojump</code> (这个可以使用自带的 <code>z</code> 来替换使用)。主题的话，就基本使用两个，一个是默认的<code>robbyrussell</code>和<code>pure</code>（<a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener">Github地址</a>）</p><h2 id="配置Tmux"><a href="#配置Tmux" class="headerlink" title="配置Tmux"></a>配置Tmux</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set -g default-terminal &quot;screen-256color&quot;</span><br><span class="line"># colors</span><br><span class="line">set -g status-bg black</span><br><span class="line">set -g status-fg white</span><br><span class="line"></span><br><span class="line"># mouse</span><br><span class="line">set -g mouse on</span><br><span class="line"></span><br><span class="line"># shell</span><br><span class="line">set -g default-shell &quot;/usr/bin/zsh&quot;</span><br><span class="line"></span><br><span class="line"># status</span><br><span class="line">set -g status-left-length 50</span><br><span class="line"></span><br><span class="line"># prefix key M-a is Alt+a</span><br><span class="line">unbind C-b</span><br><span class="line">set-option -g prefix M-a</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Tmux-And-ZSH-Install-And-Configuration/a15b4afegy1fnokpqcv02j21hc0u0jux.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;记录 Linux (Ubuntu 18.04 LTS) 下装 Tmux 和 Zsh 的过程
    
    </summary>
    
    
      <category term="Tmux" scheme="https://mikado.drrr.app/tags/Tmux/"/>
    
      <category term="Zsh" scheme="https://mikado.drrr.app/tags/Zsh/"/>
    
      <category term="Linux" scheme="https://mikado.drrr.app/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://mikado.drrr.app/First-Blog/"/>
    <id>https://mikado.drrr.app/First-Blog/</id>
    <published>2019-01-26T07:54:21.000Z</published>
    <updated>2020-04-06T15:49:46.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/First-Blog/arcipello-cherry_blossoms-clouds-landscape-nobody-original-petals-scenic-tree.jpg" alt="image"></p><p>最近逛了v2ex，发现了很多有意思的博客，去逛了逛，发现了很多有意思的内容。刚好2019新年之际，就打算给自己立了flag，写博客(逃<a id="more"></a></p><p>希望自己能坚持下去</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/First-Blog/arcipello-cherry_blossoms-clouds-landscape-nobody-original-petals-scenic-tree.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近逛了v2ex，发现了很多有意思的博客，去逛了逛，发现了很多有意思的内容。刚好2019新年之际，就打算给自己立了flag，写博客(逃
    
    </summary>
    
    
  </entry>
  
</feed>
