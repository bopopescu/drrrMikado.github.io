<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mikado&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://drrrmikado.github.io/"/>
  <updated>2019-09-01T15:50:34.489Z</updated>
  <id>https://drrrmikado.github.io/</id>
  
  <author>
    <name>Mikado</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希冲突</title>
    <link href="https://drrrmikado.github.io/Hash-Collisions/"/>
    <id>https://drrrmikado.github.io/Hash-Collisions/</id>
    <published>2019-09-01T14:39:11.000Z</published>
    <updated>2019-09-01T15:50:34.489Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Hash-Collisions/b32662efc5800fdcd75e0e9205072772.jpg" alt=""></p><h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><p>在有限的数组存储空间中，不存在一个Hash函数是能完全避免Hash冲突的。</p><h2 id="Hash-冲突"><a href="#Hash-冲突" class="headerlink" title="Hash 冲突"></a>Hash 冲突</h2><p>发生了Hash冲突，解决方法有两种，开放寻址法（Open addressing）和链表法(Chaining)。</p><a id="more"></a><ul><li>开放寻址法</li></ul><p>开放寻址法的核心思想是，出现了Hash冲突就重新找空闲的位置，将其插入。一个简单的探测方法就是<strong>线性探测</strong>（Linear Probing)。</p><p>图例：</p><p><img src="/images/Hash-Collisions/Hash-Collisions-Open-Addressing-Linear-Probing-Example.jpg" alt=""></p><p>从图中可以看出，被Hash函数计算出的位置已经有数据存在了，就往下一位放，如果到底都无法插入，就从头开始找。</p><p>这个方法的删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。假如有一个Hash冲突后的数据，要查找是否存在，通过线性探测计算出空闲位置，但是空闲位置上的数据为之前删除的，就会认定不存在。导致查找结果失败。</p><p>解决方法就是设置个特殊标记，标为这个数据为删除的。</p><p>除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重Hash</strong>（Double hashing）。</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2……</p><p>双重Hash，就是不仅要使用一个Hash函数。使用一组Hash函数，hash1、hash2、hash3……使用第一个Hash函数（hash1），计算出位置，结果不为空，就用第二个Hash函数（hash2），依次类推。</p><p>不管采用哪种探测方法，当Hash表中空闲位置不多的时候，Hash冲突的概率就会大大提高。为了尽可能保证Hash表的操作效率，一般情况下，我们会尽可能保证Hash表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p><p>装载因子的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash表的装载因子 = 填入表中的元素个数 / Hash表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，Hash表的性能会下降…对于开放定址法，装载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了装载因子为0.75，超过此值将resizeHash表。</p><ul><li>链表法</li></ul><p>链表法是比较常用的hash冲突解决方法。在Hash表中，每个“桶（Bucket）”或者“槽（Slot）”会对应一个列表</p><p>在插入的时候，计算出位置，如果位置不为空，则会插入到桶的链表中。</p><p>图例：</p><p><img src="/images/Hash-Collisions/Hash-Collisions-Chaining-Example.jpg" alt=""></p><h2 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h2><p>装载因子是表示Hsah表中元素的填满的程度，该值越大，说明Hash表中的元素越多，空闲的位置越少，Hash冲突的概率越大。不仅插入数据的过程要多次寻址或者拉很长的链表，查找过程也会因此变得很慢。</p><p>对于动态Hash表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我也无法去事先申请一个足够大的Hash表。随者数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，Hash冲突就会变得不可接受。</p><p>这个时候就需要对Hash表“动态扩容”了。针对Hash表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的Hash表，将数据搬移到新Hash表中。假设每次扩容我们都申请一个原来Hash表大小两倍的空间。如果原来Hash表的装载因子是0.8，那经过扩容之后，新Hash表的装载因子就下降为原来的一半，变成了0.4.针对数组的扩容，数据搬移操作比较简单。但是，针对Hash表的扩容，数据搬移操作要复杂很多。因为Hash表的大小变了，数据的存储位置也变了，所以我们需要通过Hash函数重新计算每个数据的存储位置。</p><p>Hash表数据不多时，数据搬移操作基本不费时间和空间，但是如果数据量很大时，搬移操作就很耗时耗空间。</p><p>解决方法是：一个新数据进来时，申请一个新的Hash表，并计算位置插入到新的Hash表。旧的Hash表数据不变。再有新的数据进来时，插入到新的Hash表，并拿旧Hash表的一个数据计算在新的Hash表中的位置并插入，重复上述过程，旧Hash表的数据就一点点的到新的Hash表中。</p><p>上述解决方法的查询顺序就是现在新的Hash表中查找，如果不存在再去旧的Hash表中查找，如果再没有，就是不存在了。</p><h2 id="如何选择Hash冲突解决方法？"><a href="#如何选择Hash冲突解决方法？" class="headerlink" title="如何选择Hash冲突解决方法？"></a>如何选择Hash冲突解决方法？</h2><ul><li>开放寻址法</li></ul><p>由于开放寻址法删除数据比较麻烦，需要标记已删除数据。在开放寻址法中，所有数据都放在一个数组里，比起链表法，开放寻址法的冲突代价更高。</p><p>所以当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java 中的ThreadLocalMap使用开放寻址法解决Hash冲突的原因。</p><ul><li>链表法</li></ul><p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</p><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的Hash冲突，致大量的探测、再Hash等，性能会下降很多。但是对于链表法来说，只要Hash函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已。虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Hash-Collisions/b32662efc5800fdcd75e0e9205072772.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Hash-函数&quot;&gt;&lt;a href=&quot;#Hash-函数&quot; class=&quot;headerlink&quot; title=&quot;Hash 函数&quot;&gt;&lt;/a&gt;Hash 函数&lt;/h2&gt;&lt;p&gt;在有限的数组存储空间中，不存在一个Hash函数是能完全避免Hash冲突的。&lt;/p&gt;
&lt;h2 id=&quot;Hash-冲突&quot;&gt;&lt;a href=&quot;#Hash-冲突&quot; class=&quot;headerlink&quot; title=&quot;Hash 冲突&quot;&gt;&lt;/a&gt;Hash 冲突&lt;/h2&gt;&lt;p&gt;发生了Hash冲突，解决方法有两种，开放寻址法（Open addressing）和链表法(Chaining)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hash" scheme="https://drrrmikado.github.io/tags/hash/"/>
    
      <category term="Data Struct" scheme="https://drrrmikado.github.io/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>TCP-协议</title>
    <link href="https://drrrmikado.github.io/TCP-Protocol/"/>
    <id>https://drrrmikado.github.io/TCP-Protocol/</id>
    <published>2019-08-29T14:30:18.000Z</published>
    <updated>2019-08-29T14:54:12.668Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/TCP-Protocol/a15b4afegy1fmviz5449mj21hc0u01kx.jpg" alt=""></p><h2 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h2><ul><li>TCP 提供一种面向连接的、可靠的字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p><a id="more"></a><h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p><ul><li><p>第一次握手(SYN=1, seq=x)</p><p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 SYN_SEND 状态。</p></li><li><p>第二次握手(SYN=1, ACK=1, seq=y,  ACKnum=x+1)</p><p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p></li><li><p>第三次握手(ACK=1，ACKnum=y+1)</p><p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p><p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p></li></ul><p>三次握手的过程的示意图如下：</p><p><img src="/images/TCP-Protocol/tcp-connection-made-three-way-handshake.png" alt="three-way-handshake"></p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p></li><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p></li><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</p></li><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p></li></ul><p>四次挥手的示意图如下：</p><p><img src="/images/TCP-Protocol/tcp-connection-closed-four-way-handshake.png" alt="four-way-handshake"></p><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul><li><p>什么是 SYN 攻击（SYN Flood）？</p><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p></li><li><p>如何检测 SYN 攻击？</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p></li><li><p>如何防御 SYN 攻击？</p><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul></li></ul><h2 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h2><p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。</p><p>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><p><a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">TCP-Keepalive-HOWTO</a> 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/TCP-Protocol/a15b4afegy1fmviz5449mj21hc0u01kx.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;TCP-的特性&quot;&gt;&lt;a href=&quot;#TCP-的特性&quot; class=&quot;headerlink&quot; title=&quot;TCP 的特性&quot;&gt;&lt;/a&gt;TCP 的特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP 提供一种面向连接的、可靠的字节流服务&lt;/li&gt;
&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP&lt;/li&gt;
&lt;li&gt;TCP 使用校验和，确认和重传机制来保证可靠传输&lt;/li&gt;
&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复&lt;/li&gt;
&lt;li&gt;TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TCP" scheme="https://drrrmikado.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化介绍</title>
    <link href="https://drrrmikado.github.io/Redis-Persistence/"/>
    <id>https://drrrmikado.github.io/Redis-Persistence/</id>
    <published>2019-02-21T09:59:51.000Z</published>
    <updated>2019-08-29T14:49:51.575Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Redis-Persistence/a15b4afegy1fmvjboz2dgj21hc0u0qj6.jpg" alt=""></p><blockquote><p>EN：<a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">https://redis.io/topics/persistence</a> <br>CN：<a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">http://www.redis.cn/topics/persistence.html</a></p></blockquote><h3 id="Redis-提供了不同级别的持久化方式"><a href="#Redis-提供了不同级别的持久化方式" class="headerlink" title="Redis 提供了不同级别的持久化方式:"></a>Redis 提供了不同级别的持久化方式:</h3><p><code>RDB</code> 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p><ul><li><code>AOF</code> 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, <code>AOF</code> 命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对 <code>AOF</code> 文件进行后台重写,使得 <code>AOF</code> 文件的体积不至于过大.</li><li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入 <code>AOF</code> 文件来恢复原始的数据,因为在通常情况下 <code>AOF</code> 文件保存的数据集要比 <code>RDB</code> 文件保存的数据集要完整.</li><li>最重要的事情是了解 <code>RDB</code> 和 <code>AOF</code> 持久化方式的不同,让我们以 <code>RDB</code> 持久化方式开始：<a id="more"></a></li></ul><h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a><code>RDB</code>优点</h3><ul><li><code>RDB</code> 持久化保存一个时间点的Redis数据</li><li><code>RDB</code> 适合容灾恢复</li><li><code>RDB</code> 最大限度地提高了Redis的性能</li><li>与 <code>AOF</code> 相比， <code>RDB</code> 允许使用大数据集更快地重启。</li></ul><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a><code>RDB</code>缺点</h3><ul><li>意外情况发生，数据会有丢失</li><li><code>RDB</code> 需要<code>fork()</code>出子进程来处理持久化，如果数据集比较大，<code>fork()</code>会很耗时的。再加上CPU性能也不是很好，耗时就会很久。 <code>AOF</code> 也是需要<code>fork()</code>的，但是 <code>AOF</code> 能调整重写无需权衡持久性的日志的频率</li></ul><h3 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a><code>AOF</code> 优点</h3><ul><li><code>AOF</code> 有多种<code>fsync</code>策略（NO <code>fsync</code>,每秒<code>fsync</code>，每个查询<code>fsync</code>）。默认的每秒<code>fsync</code>策略，写性能也是不错的（<code>fsync</code>是使用后台线程执行的，当没有<code>fsync</code>正在进行时主线程会尽力执行写操作）</li><li><code>AOF</code> 的日志的append的，所以发生意外时，使用<code>redis-check-aof</code> 工具还是能简单的修复</li><li>当Redis太大时，Redis会在后台自动重写 <code>AOF</code> 日志。重写是完全安全的，因为当Redis继续附加到旧文件时，使用创建当前数据集所需的最小操作集生成一个全新的文件，并一旦第二个文件准备就绪，Redis会切换两个并开始附加到 新的那一个。</li><li><code>AOF</code> 包含所有便于理解格式的操作日志，你可以轻松导入一个 <code>AOF</code> 文件。万一使用了<code>FLUSHALL</code>，还是能通过 <code>AOF</code> 文件恢复的。</li></ul><h3 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a><code>AOF</code> 缺点</h3><ul><li>文件比 <code>RDB</code> 大</li><li>精确<code>fsync</code>策略的话，<code>AOF</code> 比较慢。禁用<code>fsync</code>的话，跟 <code>RDB</code> 差不多快</li></ul><h3 id="快照（Snapshotting）"><a href="#快照（Snapshotting）" class="headerlink" title="快照（Snapshotting）"></a>快照（Snapshotting）</h3><p>默认的数据集快照是保存到磁盘的，一个叫 <code>dump.rdb</code>  的二进制文件。你可以配置在N秒内至少M次修改时保存快照。有两个命令 <code>SAVE</code> 和<code>BGSAVE</code>。例子，60秒内有1000key改动：<code>save 60 1000</code></p><h3 id="快照是怎么工作的（How-it-works"><a href="#快照是怎么工作的（How-it-works" class="headerlink" title="快照是怎么工作的（How it works)"></a>快照是怎么工作的（How it works)</h3><ul><li>Redis执行<code>fork</code>操作，现在有一个子进程和一个父进程。</li><li>子进程开始把数据集写入临时的 <code>RDB</code> 文件</li><li>当子进程完成写入新的 <code>RDB</code> 文件，就会替换掉旧的文件</li></ul><h3 id="附加文件（Append-only-file）"><a href="#附加文件（Append-only-file）" class="headerlink" title="附加文件（Append-only file）"></a>附加文件（Append-only file）</h3><p>快照不是非常耐用（durable）。如果发生意外（Redis停止，断电，<code>kill -9</code>），最后的Redis数据就会丢失。在1.1版本后，你可以在配置文件中开启 <code>AOF</code> ：<code>appendonly file</code>。现在开始，每次Redis接收到命令将会附加到 <code>AOF</code> 中。当Redis重启时，Redis会自己根据 <code>AOF</code> 文件重建状态。</p><h3 id="日记重写（Log-rewriting）"><a href="#日记重写（Log-rewriting）" class="headerlink" title="日记重写（Log rewriting）"></a>日记重写（Log rewriting）</h3><p><code>AOF</code> 会根据执行越来越大。例如，如果将一个计数器递增100次，则最终会在数据集中包含一个包含最终值的key，但在 <code>AOF</code> 中会有100个条目。重建当前状态其实不需要其中99个条目。在Redis 2.2中有 <code>BGREWRITEAOF</code>  这个命令，这个会分析出重建当前数据集所需最短的命令。在Redis 2.4之后就会自动执行（更多信息需要看配置文件）。</p><h3 id="AOF-的持久性如何？（How-durable-is-the-append-only-file"><a href="#AOF-的持久性如何？（How-durable-is-the-append-only-file" class="headerlink" title="AOF 的持久性如何？（How durable is the append only file?)"></a><code>AOF</code> 的持久性如何？（How durable is the append only file?)</h3><p><code>AOF</code> 有三种配置来配置备份频率</p><ul><li>每个命令都<code>fsync</code>备份。非常非常慢，但是非常安全。</li><li>每秒<code>fsync</code>备份。如果发送意外，最多也就丢失1s的数据</li><li>不<code>fsync</code>备份。<br><code>AOF</code> 默认是第二个(每秒<code>fsync</code>备份)。</li></ul><h3 id="如果-AOF-文件损坏怎么处理"><a href="#如果-AOF-文件损坏怎么处理" class="headerlink" title="如果 AOF 文件损坏怎么处理"></a>如果 <code>AOF</code> 文件损坏怎么处理</h3><ul><li>备份你的 <code>AOF</code> 文件</li><li>使用Redis自带的<code>redis-check-aof</code>工具。 <code>$ redis-check-aof --fix</code></li><li>(可选)使用 <code>diff -u</code> 来查看两个文件的不同</li><li>使用修复后的文件重启Redis服务服务器</li></ul><h3 id="怎么修复的？"><a href="#怎么修复的？" class="headerlink" title="怎么修复的？"></a>怎么修复的？</h3><ul><li>Redis执行<code>fork</code>操作，现在有一个子进程和一个父进程。</li><li>子进程开始写新的 <code>AOF</code> 到临时文件</li><li>父进程把所有新的改动缓存到内存缓冲区（in-memory buffer）（同时也会把新的改动append到旧的 <code>AOF</code> 文件）。</li><li>当子进程完成后，父进程得到一个信号，开始将内存缓冲区的数据append到新的 <code>AOF</code> 文件中</li><li>Redis会进行原子性的重命名，将临时文件重命名为新的。并开始appending旧的数据。</li></ul><h3 id="怎么从-RDB-切换到-AOF"><a href="#怎么从-RDB-切换到-AOF" class="headerlink" title="怎么从 RDB 切换到 AOF"></a>怎么从 <code>RDB</code> 切换到 <code>AOF</code></h3><p>在Redis 2.2之后有不同的操作方式</p><p><em>Redis &gt;= 2.2</em></p><ul><li>备份最新的<code>dump.rdb</code>文件，并移动到安全的地方。</li><li>发送两个命令 <code>redis-cli config set appendonly yes</code> 和 <code>redis-cli config set save &quot;&quot;</code>。</li><li>确保写命令会被正确地追加到  <code>AOF</code>  文件的末尾。</li><li>执行的第一条命令开启了 <code>AOF</code> 功能： Redis 会阻塞直到初始 <code>AOF</code> 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 <code>AOF</code>  文件末尾。</li></ul><p>执行的第二条命令用于关闭 <code>RDB</code> 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 <code>RDB</code> 和 <code>AOF</code> 这两种持久化功能。</p><p><strong>重要</strong>:别忘了在 <code>redis.conf</code> 中打开 <code>AOF</code> 功能！ 否则的话， 服务器重启之后， 之前通过 <code>CONFIG SET</code> 设置的配置就会被失效，程序会按原来的配置来启动服务器</p><p><em>Redis 2.0</em></p><ul><li>备份最新的<code>dump.rdb</code> 文件，并移动到安全的地方</li><li>停止写入。</li><li>执行 <code>redis-cli bgrewriteaof</code>， 这个会创建 <code>AOF</code> 文件。</li><li>生成完 <code>AOF</code> 文件就停止Redis服务器。</li><li><code>redis.conf</code>中开启 <code>AOF</code> 持久化。</li><li>重启Redis服务器。</li><li>确保您的数据库包含相同数量的Key。</li><li>确保写入正确附加到 <code>AOF</code> 文件。</li></ul><h3 id="AOF-和-RDB-之间的相互作用"><a href="#AOF-和-RDB-之间的相互作用" class="headerlink" title="AOF 和 RDB 之间的相互作用"></a><code>AOF</code> 和 <code>RDB</code> 之间的相互作用</h3><p>在版本号大于等于 2.4 的 Redis 中，<code>BGSAVE</code> 执行的过程中，不可以执行 <code>BGREWRITEAOF</code> 。反过来说，在 <code>BGREWRITEAOF</code> 执行的过程中， 也不可以执行 <code>BGSAVE</code>。这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p><p>如果 <code>BGSAVE</code> 正在执行， 并且用户显示地调用 <code>BGREWRITEAOF</code> 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户，<code>BGREWRITEAOF</code> 已经被预定执行： 一旦 <code>BGSAVE</code> 执行完毕，<code>BGREWRITEAOF</code> 就会正式开始。 当 Redis 启动时， 如果 <code>RDB</code> 持久化和 <code>AOF</code> 持久化都被打开了， 那么程序会优先使用  <code>AOF</code> 文件来恢复数据集， 因为 <code>AOF</code> 文件所保存的数据通常是最完整的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Redis-Persistence/a15b4afegy1fmvjboz2dgj21hc0u0qj6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EN：&lt;a href=&quot;https://redis.io/topics/persistence&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://redis.io/topics/persistence&lt;/a&gt; &lt;br&gt;CN：&lt;a href=&quot;http://www.redis.cn/topics/persistence.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/topics/persistence.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Redis-提供了不同级别的持久化方式&quot;&gt;&lt;a href=&quot;#Redis-提供了不同级别的持久化方式&quot; class=&quot;headerlink&quot; title=&quot;Redis 提供了不同级别的持久化方式:&quot;&gt;&lt;/a&gt;Redis 提供了不同级别的持久化方式:&lt;/h3&gt;&lt;p&gt;&lt;code&gt;RDB&lt;/code&gt; 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AOF&lt;/code&gt; 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, &lt;code&gt;AOF&lt;/code&gt; 命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对 &lt;code&gt;AOF&lt;/code&gt; 文件进行后台重写,使得 &lt;code&gt;AOF&lt;/code&gt; 文件的体积不至于过大.&lt;/li&gt;
&lt;li&gt;如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.&lt;/li&gt;
&lt;li&gt;你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入 &lt;code&gt;AOF&lt;/code&gt; 文件来恢复原始的数据,因为在通常情况下 &lt;code&gt;AOF&lt;/code&gt; 文件保存的数据集要比 &lt;code&gt;RDB&lt;/code&gt; 文件保存的数据集要完整.&lt;/li&gt;
&lt;li&gt;最重要的事情是了解 &lt;code&gt;RDB&lt;/code&gt; 和 &lt;code&gt;AOF&lt;/code&gt; 持久化方式的不同,让我们以 &lt;code&gt;RDB&lt;/code&gt; 持久化方式开始：
    
    </summary>
    
    
      <category term="Redis" scheme="https://drrrmikado.github.io/tags/Redis/"/>
    
      <category term="Linux" scheme="https://drrrmikado.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu服务器安装</title>
    <link href="https://drrrmikado.github.io/Ubuntu-Server-Install-Note/"/>
    <id>https://drrrmikado.github.io/Ubuntu-Server-Install-Note/</id>
    <published>2019-01-31T02:07:09.000Z</published>
    <updated>2019-08-29T14:50:31.877Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Ubuntu-Server-Install-Note/0072Vf1pgy1foxk73gascj31hc0u07e1.jpg" alt=""></p><p>This is a note when I installing Ubuntu 18.04 LTS Server. </p><h2 id="Before-install"><a href="#Before-install" class="headerlink" title="Before install"></a>Before install</h2><h3 id="Change-SSH-port"><a href="#Change-SSH-port" class="headerlink" title="Change SSH port"></a>Change SSH port</h3><ol><li>Edit ssh config</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ol start="2"><li>Change port</li><li>Restart sshd service</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Add-user"><a href="#Add-user" class="headerlink" title="Add user"></a>Add user</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /bin/bash &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="Edit-visudo"><a href="#Edit-visudo" class="headerlink" title="Edit visudo"></a>Edit visudo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><ul><li>if <code>visudo</code> is using <code>nano</code>, you can use <code>update-alternatives --config editor</code> chage default editor.</li></ul><h3 id="Set-up-user-password"><a href="#Set-up-user-password" class="headerlink" title="Set up user password"></a>Set up user password</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-user"><a href="#Change-user" class="headerlink" title="Change user"></a>Change user</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="Update-sources-mirror"><a href="#Update-sources-mirror" class="headerlink" title="Update sources mirror"></a>Update sources mirror</h3><blockquote><p><a href="https://mirrors.ustc.edu.cn/help/ubuntu.html" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/help/ubuntu.html</a></p></blockquote><ol><li>Back up sources list</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><ol start="2"><li>Has two way to update sources list.</li></ol><ul><li>If you using English, the <code>&lt;country-code&gt;</code> is empty.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i 's/&lt;country-code&gt;.archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list</span><br></pre></td></tr></table></figure><ul><li>Edit <code>/etc/apt/sources.list</code>, need <code>sudo</code>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 默认注释了源码仓库，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 预发布软件源，不建议启用</span><br><span class="line"><span class="meta">#</span> deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h3 id="Update-system"><a href="#Update-system" class="headerlink" title="Update system"></a>Update system</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="Install-develop-tool"><a href="#Install-develop-tool" class="headerlink" title="Install develop tool"></a>Install develop tool</h2><p><strong>Not root!!!</strong></p><h3 id="Vimrc-config"><a href="#Vimrc-config" class="headerlink" title="Vimrc config"></a>Vimrc config</h3><p>edit <code>~/.vimrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set number</span><br><span class="line">syntax on</span><br></pre></td></tr></table></figure><h3 id="PHP-7-2"><a href="#PHP-7-2" class="headerlink" title="PHP 7.2"></a>PHP 7.2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.2 php7.2-mysql php7.2-curl \</span><br><span class="line">    php7.2-common php7.2-xml php7.2-json \</span><br><span class="line">    php7.2-cli php7.2-bcmath php7.2-fpm \</span><br><span class="line">    php7.2-mbstring</span><br></pre></td></tr></table></figure><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><ul><li>Install composer</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"</span><br><span class="line">php -r "if (hash_file('sha384', 'composer-setup.php') === '93b54496392c062774670ac18b134c3b3a95e5a5e5c8f1a9f115f203b75bf9a129d5daa8ba6a13e2cc8a1da0806388a8') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php');&#125; echo PHP_EOL;"</span><br><span class="line">php composer-setup.php</span><br><span class="line">php -r "unlink('composer-setup.php');"</span><br><span class="line">sudo cp composer.phar /user/bin/composer</span><br></pre></td></tr></table></figure><ul><li>Set up composer packagist url</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.laravel-china.org</span><br></pre></td></tr></table></figure><h3 id="MariaDB-10-4"><a href="#MariaDB-10-4" class="headerlink" title="MariaDB-10.4"></a>MariaDB-10.4</h3><h4 id="Install-mariadb-server"><a href="#Install-mariadb-server" class="headerlink" title="Install mariadb server"></a>Install mariadb server</h4><blockquote><p><a href="https://downloads.mariadb.org/mariadb/repositories" target="_blank" rel="noopener">https://downloads.mariadb.org/mariadb/repositories</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8</span><br><span class="line">sudo add-apt-repository 'deb [arch=amd64,arm64,ppc64el] https://mirrors.shu.edu.cn/mariadb/repo/10.4/ubuntu bionic main'</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install mariadb-server</span><br></pre></td></tr></table></figure><h4 id="Add-user-1"><a href="#Add-user-1" class="headerlink" title="Add user"></a>Add user</h4><blockquote><p><a href="https://mariadb.com/kb/en/library/create-user/" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/create-user/</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">USER</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="string">'foo2'</span>@<span class="string">'test'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure><h4 id="Grant-user"><a href="#Grant-user" class="headerlink" title="Grant user"></a>Grant user</h4><blockquote><p><a href="https://mariadb.com/kb/en/library/grant" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/grant</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL ON laravel_blog.* TO 'laravel_blog'@'%'</span><br></pre></td></tr></table></figure><h4 id="Change-port"><a href="#Change-port" class="headerlink" title="Change port"></a>Change port</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Ubuntu-Server-Install-Note/0072Vf1pgy1foxk73gascj31hc0u07e1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;This is a note when I installing Ubuntu 18.04 LTS Server. &lt;/p&gt;
&lt;h2 id=&quot;Before-install&quot;&gt;&lt;a href=&quot;#Before-install&quot; class=&quot;headerlink&quot; title=&quot;Before install&quot;&gt;&lt;/a&gt;Before install&lt;/h2&gt;&lt;h3 id=&quot;Change-SSH-port&quot;&gt;&lt;a href=&quot;#Change-SSH-port&quot; class=&quot;headerlink&quot; title=&quot;Change SSH port&quot;&gt;&lt;/a&gt;Change SSH port&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Edit ssh config&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo vim /etc/ssh/sshd_config&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Change port&lt;/li&gt;
&lt;li&gt;Restart sshd service&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service sshd restart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://drrrmikado.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://drrrmikado.github.io/tags/Ubuntu/"/>
    
      <category term="Linux Server" scheme="https://drrrmikado.github.io/tags/Linux-Server/"/>
    
  </entry>
  
  <entry>
    <title>Tmux和Zsh的安装与配置</title>
    <link href="https://drrrmikado.github.io/Tmux-And-ZSH-Install-And-Configuration/"/>
    <id>https://drrrmikado.github.io/Tmux-And-ZSH-Install-And-Configuration/</id>
    <published>2019-01-27T13:08:54.000Z</published>
    <updated>2019-08-29T14:52:18.062Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Tmux-And-ZSH-Install-And-Configuration/a15b4afegy1fnokpqcv02j21hc0u0jux.jpg" alt=""></p><p>记录 Linux (Ubuntu 18.04 LTS) 下装 Tmux 和 Zsh 的过程<a id="more"></a></p><h2 id="安装Tmux和Zsh"><a href="#安装Tmux和Zsh" class="headerlink" title="安装Tmux和Zsh"></a>安装Tmux和Zsh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update </span><br><span class="line">sudo apt install tmux zsh</span><br></pre></td></tr></table></figure><h2 id="配置Zsh"><a href="#配置Zsh" class="headerlink" title="配置Zsh"></a>配置Zsh</h2><h3 id="安装Oh-My-Zsh"><a href="#安装Oh-My-Zsh" class="headerlink" title="安装Oh-My-Zsh"></a>安装Oh-My-Zsh</h3><blockquote><p>具体内容可以查看<a href="https://ohmyz.sh/" target="_blank" rel="noopener">官网</a></p></blockquote><ul><li>使用 <code>curl</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>wget</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>使用的插件有 <code>zsh-syntax-highlighting</code>，<code>zsh-autosuggestions</code>，<code>autojump</code> (这个可以使用自带的 <code>z</code> 来替换使用)。主题的话，就基本使用两个，一个是默认的<code>robbyrussell</code>和<code>pure</code>（<a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener">Github地址</a>）</p><h2 id="配置Tmux"><a href="#配置Tmux" class="headerlink" title="配置Tmux"></a>配置Tmux</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set -g default-terminal &quot;screen-256color&quot;</span><br><span class="line"># colors</span><br><span class="line">set -g status-bg black</span><br><span class="line">set -g status-fg white</span><br><span class="line"></span><br><span class="line"># mouse</span><br><span class="line">set -g mouse on</span><br><span class="line"></span><br><span class="line"># shell</span><br><span class="line">set -g default-shell &quot;/usr/bin/zsh&quot;</span><br><span class="line"></span><br><span class="line"># status</span><br><span class="line">set -g status-left-length 50</span><br><span class="line"></span><br><span class="line"># prefix key M-a is Alt+a</span><br><span class="line">unbind C-b</span><br><span class="line">set-option -g prefix M-a</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Tmux-And-ZSH-Install-And-Configuration/a15b4afegy1fnokpqcv02j21hc0u0jux.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;记录 Linux (Ubuntu 18.04 LTS) 下装 Tmux 和 Zsh 的过程
    
    </summary>
    
    
      <category term="Linux" scheme="https://drrrmikado.github.io/tags/Linux/"/>
    
      <category term="Tmux" scheme="https://drrrmikado.github.io/tags/Tmux/"/>
    
      <category term="Zsh" scheme="https://drrrmikado.github.io/tags/Zsh/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://drrrmikado.github.io/First-Blog/"/>
    <id>https://drrrmikado.github.io/First-Blog/</id>
    <published>2019-01-26T07:54:21.000Z</published>
    <updated>2019-08-29T14:51:51.660Z</updated>
    
    <content type="html"><![CDATA[<p>![image](/images/First-Blog/Konachan.com - 143486 arcipello cherry_blossoms clouds landscape nobody original petals scenic tree.jpg)</p><p>最近逛了v2ex，发现了很多有意思的博客，去逛了逛，发现了很多有意思的内容。刚好2019新年之际，就打算给自己立了flag，写博客(逃<a id="more"></a></p><p>希望自己能坚持下去</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;![image](/images/First-Blog/Konachan.com - 143486 arcipello cherry_blossoms clouds landscape nobody original petals scenic tree.jpg)&lt;/p&gt;
&lt;p&gt;最近逛了v2ex，发现了很多有意思的博客，去逛了逛，发现了很多有意思的内容。刚好2019新年之际，就打算给自己立了flag，写博客(逃
    
    </summary>
    
    
  </entry>
  
</feed>
